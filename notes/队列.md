1. 如何理解队列

   队列跟栈一样，也是一种操作受限的线性表数据结构

   - **先进先出**
   - **后进后出**

   基本操作：

   - 入队（enqueue）
   - 出队（dequeue）

   变体：

   - 循环队列
   - 阻塞队列
   - 并发队列

2. 顺序队列和链式队列

   顺序队列——数组实现

   ```c++
   typedef int Position;
   struct QNode {
       ElementType *Data;     /* 存储元素的数组 */
       Position Front, Rear;  /* 队列的头、尾指针 */
       int MaxSize;           /* 队列最大容量 */
   };
   typedef struct QNode *Queue;
    
   Queue CreateQueue( int MaxSize )
   {
       Queue Q = (Queue)malloc(sizeof(struct QNode));
       Q->Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));
       Q->Front = Q->Rear = 0;
       Q->MaxSize = MaxSize;
       return Q;
   }
   
   bool AddQ( Queue Q, Queue X ){
       if(Rear==MaxSize){
           return false;
       }
       Data[Rear]=x;
       Rear++;
       return true;
   }
   ElementType DeleteQ( Queue Q ){
       if(Front==Rear){
           return NULL;
       }
       ElementType temp=Data[Front];
       Front++;
       return temp;
   }
   ```



   链式队列——链表实现

   ```c++
   typedef struct Node *PtrToNode;
   struct Node { /* 队列中的结点 */
       ElementType Data;
       PtrToNode Next;
   };
   typedef PtrToNode Position;
    
   struct QNode {
       Position Front, Rear;  /* 队列的头、尾指针 */
       int MaxSize;           /* 队列最大容量 */
   };
   typedef struct QNode *Queue;
    
   bool IsEmpty( Queue Q )
   {
       return ( Q->Front == NULL);
   }
    
   ElementType DeleteQ( Queue Q )
   {
       Position FrontCell; 
       ElementType FrontElem;
        
       if  ( IsEmpty(Q) ) {
           printf("队列空");
           return ERROR;
       }
       else {
           FrontCell = Q->Front;
           if ( Q->Front == Q->Rear ) /* 若队列只有一个元素 */
               Q->Front = Q->Rear = NULL; /* 删除后队列置为空 */
           else                     
               Q->Front = Q->Front->Next;
           FrontElem = FrontCell->Data;
    
           free( FrontCell );  /* 释放被删除结点空间  */
           return  FrontElem;
       }
   }
   
   bool AddQ( Queue Q, Queue X ){
       if  ( IsEmpty(Q) ) {
           front=rear=x;
       }
       rear->next=x;
       rear=rear->next;
       return ture;
   }
   ```

3. 循环队列

   ```c++
   typedef int Position;
   struct QNode {
       ElementType *Data;     /* 存储元素的数组 */
       Position Front, Rear;  /* 队列的头、尾指针 */
       int MaxSize;           /* 队列最大容量 */
   };
   typedef struct QNode *Queue;
    
   Queue CreateQueue( int MaxSize )
   {
       Queue Q = (Queue)malloc(sizeof(struct QNode));
       Q->Data = (ElementType *)malloc(MaxSize * sizeof(ElementType));
       Q->Front = Q->Rear = 0;
       Q->MaxSize = MaxSize;
       return Q;
   }
    
   bool IsFull( Queue Q )
   {
       return ((Q->Rear+1)%Q->MaxSize == Q->Front);
   }
    
   bool AddQ( Queue Q, ElementType X )
   {
       if ( IsFull(Q) ) {
           printf("队列满");
           return false;
       }
       else {
           Q->Rear = (Q->Rear+1)%Q->MaxSize;
           Q->Data[Q->Rear] = X;
           return true;
       }
   }
    
   bool IsEmpty( Queue Q )
   {
       return (Q->Front == Q->Rear);
   }
    
   ElementType DeleteQ( Queue Q )
   {
       if ( IsEmpty(Q) ) { 
           printf("队列空");
           return ERROR;
       }
       else  {
           Q->Front =(Q->Front+1)%Q->MaxSize;
           return  Q->Data[Q->Front];
       }
   }
   ```

   队满时，其实有一个数据域没有存储数据

   - 可以避免

4. 阻塞队列和并发队列

   阻塞队列：在队列基础上**增加了阻塞操作**

   - 如果在队列为空的时候，从队头取数据会被阻塞。
     - 因为此时还没有数据可取，直到队列中有了数据才能返回；
   - 如果队列已经满了，那么插入数据的操作就会被阻塞，
     - 直到队列中有空闲位置后再插入数据，然后再返回

   可以使用阻塞队列，实现一个“**生产者 - 消费者模型**”——可以有效地协调生产和消费的速度

   - 当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了
     - 这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”
   - 基于阻塞队列，还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率
     - 可以多配置几个“消费者”，来应对一个“生产者”

   并发队列：——线程安全的队列

    - to do

 5. 队列队列在线程池等有限资源池中的应用

    线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？

    非阻塞的处理方式：直接拒绝任务请求

    阻塞的处理方式：将请求排队，等到有空闲线程时，取出排队的请求继续处理

    - 公平地处理每个排队的请求，先进者先服务——队列（适合来存储排队请求）
      - 基于链表
        - 可以实现一个支持无限排队的无界队列
        - 可能会导致过多的请求排队等待，请求处理的响应时间过长
        - 针对响应时间比较敏感的系统
      - 基于数组
        - 队列的大小有限制
          - 太大导致等待的请求太多，
          - 太小会导致无法充分利用系统资源、发挥最大性能
          - 合理的大小——讲究
        - 所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝
        - 针对响应时间敏感的系统


