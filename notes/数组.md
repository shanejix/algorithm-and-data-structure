1. 数组如何实现随机访问？

   数组的特点

   - **线性表**数据结构，
     - 包括数组，链表，队列，栈
     - 而二叉树，堆，图等是非线性
   - 用一组**连续的内存空间**来储存相同或不同的类型的数据

   因此，具备**“随机访问”**的特性，但也是缺点

   - 插入，删除数据为了保证数组的连续性，需要做必要的搬移工作
   - 所以，低效

   数组下标如何实现随机访问

   - 访问某个数组中某个元素时，通过寻址公式，计算该元素的内存地址

     ```cpp
     a[i]_address = base_address + i * data_type_size
     ```

   数组和链表的区别

   - **数组支持随机访问，根据下标随机访问的时间复杂度是O(1)**
   - 数组有序，二分查找的时间复杂度是O(logn)
   - 链表适合插入，删除，时间复杂度O(1)

   ​	

2. 低效的插入和删除

   为什么会低效？——

   将一个数据插入到第k个位置（有序数组中）

   - 把第k个位置腾出来——给新来的数据
   - 将k~n部分元素顺序往后挪一位
   - 时间复杂度
     - 在数组末尾插入元素，不用挪动数据——最好时间复杂度O(1)
     - 在数组开头插入元素，所有元素往后挪一位——最坏时间复杂度O(n)
     - 假设每个位置插入元素的几率一样——平均时间复杂度O(n)

   - 如果数组中的数据没有规律（无序）（集合）——
     - 避免大规模的数据搬移
     - 直接将k位置的数据搬到数组的末尾
     - 新的元素直接插入第k个位置
     - 时间复杂度
       - 在这种特定的场景下，插入的时间复杂度降为——O(1)

   删除操作和插入操作类似

   - 删除数组末尾的数据——最好时间复杂度O(1)
   - 删除开头的数据——最坏时间复杂度O(n)
   - 平均时间复杂度——O(n)

   实际上，**在不追求数组中数据的连续性时，可以将多次删除操作集中在一起处理**

   - JVM垃圾回收算法的核心思想

   ​	

   ​	

   ​	

3. 警惕数组访问越界问题

   ```cpp
   int main(int argc, char* argv[]){
       int i = 0;
       int arr[3] = {0};
       for(; i<=3; i++){
           arr[i] = 0;
           printf("hello world\n");
       }
       return 0;
   }
   
   //无限打印hello world
   
   //函数体内的局部变量存在栈上，且是连续压栈,在Linux进程的内存布局中，栈区在高地址空间，
   //从高向低增长,首先压栈的i，a[2]，a[1]，a[0],变量i和arr在相邻地址，且i比arr的地址大，所以arr越界正好访问到i。
   //当然，前提是i和arr元素同类型
   
   ```

4. 容器和数组

   - 容器类将数组的操作封装，支持动态扩容，内置方法，有一定的性能损耗

   - 如果数据的大小实现知道，操作简单，直接使用数组
   - 底层开发使用数组——最求性能

5. 为什么大多语言中数组的都从0开始编号？

   - 从数组的内存模型上看

     - “小标”的确切定义是——**偏移(offset)**

       ```cpp
       //a 来表示数组的首地址，
       //a[0] 就是偏移为 0 的位置，也就是首地址，
       //a[k] 就表示偏移 k 个 type_size的位置
       
       //a[k] 的内存地址公式：
       
       a[k]_address = base_address + k * type_size
       
       //如果数组从 1 开始计数，
       //a[k] 的内存地址公式：
       
       a[k]_address = base_address + (k-1)*type_size
       
       
       
       //二维数组内存寻址：
       //对于 m * n 的数组，a [ i ][ j ] (i < m,j < n)的地址为：
       
       address = base_address + ( i * n + j) * type_size
       ```

     - 从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于
       CPU 来说，就是多了一次减法指令。（不要小看一次指令）
     - 数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开
       始

   - 历史遗留原因