# 链表

和数组相反，链表的存储空间不是一块连续的内存空间——通过指针将“零散”的内存块串联起来

1. 内存块——**结点**包含

   - 数据域（存储数据）

   - 指针域（记录指向结点的地址）

2. 常见链表结构

   - ### **单向链表**
     - **头结点**——第一个结点(记录链表的基地址)
     - **尾结点**——链表的最后一个结点(指向 NULL)
     - 插入和删除操作
       - 链表的内存空间不是连续储存的
       - 因此，只需考虑相邻结点指针的改变——事件复杂度 O(1)
       - 弊端，随机访问——时间复杂度 O(n)
       - 数组根据首地址和下标，通过寻址公式直接计算出内存地址
       - 链表必须依次遍历结点，直到找到该结点
   - ### **双向链表**
     - 指针域包含
       - 前驱指针(prev)
       - 后继指针(next)
     - 需要额外的空间来存储指针域——消耗更多的内存空间
     - 支持**双向遍历（灵活）**
       - 删除操作
       - 删除结点中“值等于某个给定值”的结点
       - （单）双向链表都需要从头依次遍历，直到找到给定值的结点
       - 删除给定指针指向的结点
       - 删除某个结点需要知道其前驱结点
       - 单向链表不能直接获取前驱结点，需要从头遍历链表，时间复杂度 O(n)
       - 双向链表可以 O(1)时间复杂度度找到前驱节点
       - 插入操作
       - 在链表的某个结点前面插入一个结点
         - 双向链表——O(1)
         - 单向链表——O(n)
       - 有序链表，双向链表比单向链表有优势
     - 为什么双向链表更加消耗内存但是应用更加广泛呢？
       - **空间换时间的设计思想**——内存充足，追求速度
       - 相反，空间紧缺（单片机）——时间换空间
   - ### **循环链表**

     - 尾结点指针指向链表的头结点
     - 适合处理具有循环结构的数据（约瑟夫问题）

   - 双向循环链表

3. 链表 VS 数组

   | 时间复杂度 | 数组 | 链表 |
   | :--------: | :--: | :--: |
   | 插入，删除 | O(n) | O(1) |
   |  随机访问  | O(1) | O(n) |

   - 数组内存空间是连续存储的，借助 CPU 缓存机制，效率高
   - 链表对 CPU 缓存不友好
   - 数组一经声明，需要占用整块连续的空间
     - 声明过大，内存不足
     - 声明过小，不够用，则需申请更大的内存空间，拷贝原数组，耗时
   - 链表，天然支持“动态扩容”

4. 实现缓存淘汰算法

   常见的策略：

   - 先进先出策略 FIFO（First In，First Out）
   - 最少使用策略 LFU（Least Frequently Used）
   - 最近最少使用策略 LRU（Least Recently Used）
     - 维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。
     - 当有一个新的数据被访问时，从链表头开始顺序遍历链表。
       1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位
          置删除，然后再插入到链表的头部。
       2. 如果此数据没有在缓存链表中，又可以分为两种情况：
       - 如果此时缓存未满，则将此结点直接插入到链表的头部；
       - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部

5. 链表代码技巧

   1. 指针和引用

      - 指针用于保存变量的地址
        - p->next
        - p->next->next
      - 引用（实际上是 const 的指针）

   2. 指针丢失

      ```cpp
      p->next=x;
      x->next=p->next;
      //丢失了，
      //可以借助第三个变量
      //或者，交换位置
      x->next=p->next;
      p->next=x;
      ```

   3. 利用哨兵

      - 带头结点

        ```cpp
        //单链表插入删除操作

        //插入
        new_node->next = p->next;
        p->next=new_node;

        //删除
        p->next=p->next->next;

        //如果向空链表中插入删除结点，补充逻辑

        //插入
        if(p==null){
            p=new_node;
        }
        //删除
        if(p->next=null){
            p=null;
        }

        //插入和删除链表需要对空结点特殊处理

        //繁琐，容易考虑不全

        //哨兵——

        //带头结点，统一逻辑，数据域不存储数据

        //插入
        new_head->next=head->next;
        head->next=new_head;
        //删除
        head->next=head->next->next;
        ```

   4. 边界条件处理

      - 如果链表为空时
      - 如果链表只包含一个结点时
      - 如果链表只包含两个结点时
      - 代码逻辑在处理头结点和尾结点时
      - 特殊场景（...）

   5. 举例画图（辅助思考），复杂问题简单化

6. 常见链表操作

   - 单链表翻转
   - 链表中环的检测
   - 两（多个）个有序链表的合并
   - 删除链表倒数第 n 个结点
   - 求链表的中间结点
   - 求两个链表的交点
