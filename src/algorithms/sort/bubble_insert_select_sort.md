
### 时间复杂度为 O(n^2)排序算法

|     排序算法     | 时间复杂度 | 是否基于比较 |
| :--------------: | :--------: | :----------: |
| 冒泡，插入，选择 |  `O(n^2)`  |      是      |


#### 冒泡排序

##### 思路

- 冒泡排序只会操作相邻的两个数据

- 每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求
- 如果(不)满足就让它俩互换。
- 一次冒泡会让至少一个元素移动到它应该在的位置，（一轮比较会让最大或最小元素冒泡）
- 重复 n 次，就完成了 n 个数据的排序工作

##### 优化

- 当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作

```c++
// 冒泡排序，a 表示数组，n 表示数组大小
void bubbleSort(int[] a, int n) {
	if (n <= 1) return;
    for (int i = 0; i < n; ++i) {
        // 提前退出冒泡循环的标志位
        boolean flag = false;
        for (int j = 0; j < n - i - 1; ++j) {
            if (a[j] > a[j+1]) { // 交换
                int tmp = a[j];
                a[j] = a[j+1];
                a[j+1] = tmp;
                flag = true; // 表示有数据交换
            }
    	}
    	if (!flag) break; // 没有数据交换，提前退出
    }
}
```

##### 冒泡排序是就地排序吗？

- 只涉及相邻数据的交换，常量级的临时空间，空间复杂度是 O(1),是就地排序

##### 冒泡排序是稳定排序吗？

- 两个元素大小相等时，不做交换，在排序前后的相对位置不变，是稳定排序

##### 冒泡排序的事件复杂度？

- 最好情况下，数据完全有序，进行一次冒泡操作，时间复杂度是 O(1)

- 最坏情况下，数据逆序，需要进行 n 次冒泡操作，事件复杂度是 O(n^2)

- 平均时间复杂度（加权平均期望时间复杂度）
  - 结合概率论
    - 对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的
  - “有序度”和“逆序度”（默认从小到大为有序）

 有序度是数组中具有有序关系的元素对的个数

 `有序元素对：a[i] <= a[j], 如果 i < j`

 `逆序元素对：a[i] > a[j], 如果 i < j`

 完全有序的数组的有序度叫作满有序度：

 `n*(n-1)/2`

 公式：

 `逆序度 = 满有序度 - 有序度`

 `满有序度 = 逆序度 + 有序度`

 **排序就是增加有序度，减少逆序度，最后达到满有序度的过程，排序就完成**

##### 对于包含 n 个数据的数组进行冒泡排序

- 最坏情况下，初始状态的有序度是 0，所以要进行 n(n-1)/2 次交换
- 最好情况下，初始状态的有序度是 n(n-1)/2，就不需要进行交换
- 可以取个中间值 n\*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况
- 比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况下的时间复杂度就是 O(n^2)

##### 冒泡排序包含两个操作原子，

- 比较（从前向后，从后向前）
- 和交换
  - 每交换一次，有序度就加 1
  - 不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是 n\*(n-1)/2–初始有序度

#### 插入排序

##### 一个有序的数组，往里面添加一个新的数据后，如何继续保持数据有序呢？

- 遍历数组，找到适当的位置插入即可

- 动态的排序过程（动态地向有序集合力添加数据）

##### 插入排序的思路

- 将数组中的数据分为两个区间，
  - 已排序区间（初始已排序区间只有一个元素，就是数组的第一个元素）
  - 和未排序区间
- （核心）取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序
- 重复这个过程，直到未排序区间中元素为空，算法结束

##### 插入排序也包含两种操作

- 一种是元素的比较，
  - 需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置
- 一种是元素的移动
  - 找到插入点之后，需要将插入点之后的元素顺序往后移动一位，腾出位置给元素 a 插入

##### 查找插入点方法

- 从头到尾、
- 从尾到头
- 元素的比较次数是有区别的
- 但对于一个给定的初始序列，移动操作的次数是固定的，等于逆序度

```c++
// 插入排序，a 表示数组，n 表示数组大小
void insertionSort(int[] a, int n) {
	if (n <= 1) return;

    for (int i = 1; i < n; ++i) {
        int value = a[i];
        int j = i - 1;
        // 查找插入的位置
        for (; j >= 0; --j) {//从后向前
            if (a[j] > value) {
                a[j+1] = a[j]; // 数据移动
            } else {
                break;
            }
		}
		a[j+1] = value; // 插入数据
	}
}
```

##### 插入排序是原地排序算法吗？

- 插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，是一个原地排序算法

##### 插入排序是稳定的排序算法吗？

- 在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后
  面，这样就可以保持原有的前后顺序不变，插入排序是稳定的排序算法

##### 插入排序的时间复杂度是多少？

- 如果要排序的数据已经是有序的，并不需要搬移任何数据。
  - 如果**从尾到头**在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。
  - 所以这种情况下，最好是时间复杂度为 O(n)
- 如果数组是倒序的，
  - 每次插入都相当于在数组的第一个位置插入新的数据，
  - 所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n )
- 平均时间复杂度
  - 在数组中插入一个数据的平均时间复杂度是多少？—— O(n)
  - 对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，
  - 所以平均时间复杂度为 O(n^2)

#### 选择排序

##### 选择排序的思路：（类似插入排序）

- 将数组中的数据分为两个区间，
  - 已排序区间
  - 和未排序区间
  - 选择排序每次会从未排序区间中找到最小（大）的元素，将其放到已排序区间的末尾

##### 选择排序是就地排序吗？

- 选择排序空间复杂度为 O(1)，是一种原地排序算法

##### 选择排序的时间复杂度是多少？

- 选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)

##### 选择排序是稳定的排序算法吗？

- 选择排序是一种不稳定的排序算法
  - 选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性

##### 冒泡排序和插入排序的时间复杂度都是 O(n )，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？

- 冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度

- 插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度

- 冒泡排序的数据交换要比插入排序的数据移动要复杂，

  - 冒泡排序需要 3 个赋值操作，
  - 而插入排序只需要 1 个移动操作

  ```c++

  冒泡排序中数据的交换操作：
  if (a[j] > a[j+1]) { // 交换
      int tmp = a[j];
      a[j] = a[j+1];
      a[j+1] = tmp;
      flag = true;
  }
  插入排序中数据的移动操作：
  if (a[j] > value) {
      a[j+1] = a[j]; // 数据移动
  }
  else {
      break;
  }
  ```

理论上：

- 执行一个赋值语句的时间粗略地计为单位时间（unit_time），
- 然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序
  - 用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3\*K 单位时间
  - 而插入排序中数据移动操作只需要 K 个单位时间
- 虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n^2)，
- 但是为了把性能优化做到极致，那肯定首选插入排序
