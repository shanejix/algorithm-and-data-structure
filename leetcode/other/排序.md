####如何评价，分析一个排序算法？

- 排序算法的执行效率

  1. 最好情况，最坏情况，平均情况时间复杂度

     不同时间复杂度下，对应的原始数据（规模大小，有序，近乎有序，无序，乱序）

  2. 时间复杂度的系数，常数，低阶

     同阶复杂度的算法对比算法性能时考虑系数，常数，低阶

  3. 比价次数和交换（或移动）次数

     基于排序算法

- 排序算法的内存消耗

  内存消耗——空间复杂度

  引入：就地排序（原地排序）（sorted in place）

  - 不利用额外的空间（常量级的空间）
  - 空间复杂度是O(1)的排序算法

- 排序算法的稳定性

  经过排序之后，相等元素之间原有的先后顺序不变

  实例：按照对象的某个属性值排序（应用广泛）

####时间复杂度为O(n^2)排序算法

|     排序算法     | 时间复杂度 | 是否基于比较 |
| :--------------: | :--------: | :----------: |
| 冒泡，插入，选择 |   O(n^2)   |      是      |
|   快排，归并，   |  O(nlogn)  |      是      |
|  桶，计数，基数  |    O(n)    |      否      |

#####冒泡排序

######思路：

- 冒泡排序只会操作相邻的两个数据

- 每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求
- 如果(不)满足就让它俩互换。
- 一次冒泡会让至少一个元素移动到它应该在的位置，（一轮比较会让最大或最小元素冒泡）
- 重复n 次，就完成了 n 个数据的排序工作

######优化：

- 当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作

```c++
// 冒泡排序，a 表示数组，n 表示数组大小
void bubbleSort(int[] a, int n) {
	if (n <= 1) return;
    for (int i = 0; i < n; ++i) {
        // 提前退出冒泡循环的标志位
        boolean flag = false;
        for (int j = 0; j < n - i - 1; ++j) {
            if (a[j] > a[j+1]) { // 交换
                int tmp = a[j];
                a[j] = a[j+1];
                a[j+1] = tmp;
                flag = true; // 表示有数据交换
            }
    	}
    	if (!flag) break; // 没有数据交换，提前退出
    }
}
```

######冒泡排序是就地排序吗？

- 只涉及相邻数据的交换，常量级的临时空间，空间复杂度是O(1),是就地排序

######冒泡排序是稳定排序吗？

- 两个元素大小相等时，不做交换，在排序前后的相对位置不变，是稳定排序

######冒泡排序的事件复杂度？

- 最好情况下，数据完全有序，进行一次冒泡操作，时间复杂度是O(1)

- 最坏情况下，数据逆序，需要进行n次冒泡操作，事件复杂度是O(n^2)

- 平均时间复杂度（加权平均期望时间复杂度）
  - 结合概率论
    - 对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的
  - “有序度”和“逆序度”（默认从小到大为有序）

​		有序度是数组中具有有序关系的元素对的个数

​		`有序元素对：a[i] <= a[j], 如果 i < j`

​		`逆序元素对：a[i] > a[j], 如果 i < j`

​		完全有序的数组的有序度叫作满有序度：

​		`n*(n-1)/2`

​		公式：

​		`逆序度 = 满有序度 - 有序度`

​		`满有序度 =  逆序度 + 有序度`

​		**排序就是增加有序度，减少逆序度，最后达到满有序度的过程，排序就完成**

######对于包含 n 个数据的数组进行冒泡排序

- 最坏情况下，初始状态的有序度是 0，所以要进行 n(n-1)/2 次交换
- 最好情况下，初始状态的有序度是 n(n-1)/2，就不需要进行交换
- 可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况
- 比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)，所以平均情况下的时间复杂度就是 O(n^2)

######冒泡排序包含两个操作原子，

- 比较（从前向后，从后向前）
- 和交换
  - 每交换一次，有序度就加 1
  - 不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2–初始有序度

#####插入排序

######一个有序的数组，往里面添加一个新的数据后，如何继续保持数据有序呢？

- 遍历数组，找到适当的位置插入即可

- 动态的排序过程（动态地向有序集合力添加数据）

######插入排序的思路：

- 将数组中的数据分为两个区间，
  - 已排序区间（初始已排序区间只有一个元素，就是数组的第一个元素）
  - 和未排序区间
- （核心）取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序
- 重复这个过程，直到未排序区间中元素为空，算法结束

######插入排序也包含两种操作：

- 一种是元素的比较，
  - 需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置
- 一种是元素的移动
  - 找到插入点之后，需要将插入点之后的元素顺序往后移动一位，腾出位置给元素 a 插入

######查找插入点方法：

- 从头到尾、
- 从尾到头
- 元素的比较次数是有区别的
- 但对于一个给定的初始序列，移动操作的次数是固定的，等于逆序度

```c++
// 插入排序，a 表示数组，n 表示数组大小
void insertionSort(int[] a, int n) {
	if (n <= 1) return;
    
    for (int i = 1; i < n; ++i) {
        int value = a[i];
        int j = i - 1;
        // 查找插入的位置
        for (; j >= 0; --j) {//从后向前
            if (a[j] > value) {
                a[j+1] = a[j]; // 数据移动
            } else {
                break;
            }
		}
		a[j+1] = value; // 插入数据
	}
}
```

######插入排序是原地排序算法吗？

- 插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是O(1)，是一个原地排序算法

######插入排序是稳定的排序算法吗？

- 在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后
  面，这样就可以保持原有的前后顺序不变，插入排序是稳定的排序算法

######插入排序的时间复杂度是多少？

- 如果要排序的数据已经是有序的，并不需要搬移任何数据。
  - 如果**从尾到头**在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。
  - 所以这种情况下，最好是时间复杂度为 O(n)
- 如果数组是倒序的，
  - 每次插入都相当于在数组的第一个位置插入新的数据，
  - 所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n )
- 平均时间复杂度
  - 在数组中插入一个数据的平均时间复杂度是多少？—— O(n)
  - 对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，
  - 所以平均时间复杂度为 O(n^2)

######优化：

to do

希尔排序

#####选择排序

######选择排序的思路：（类似插入排序）

- 将数组中的数据分为两个区间，
  - 已排序区间
  - 和未排序区间
  - 选择排序每次会从未排序区间中找到最小（大）的元素，将其放到已排序区间的末尾

######选择排序是就地排序吗？

- 选择排序空间复杂度为 O(1)，是一种原地排序算法

######选择排序的时间复杂度是多少？

- 选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)

######选择排序是稳定的排序算法吗？

- 选择排序是一种不稳定的排序算法
  - 选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性

######冒泡排序和插入排序的时间复杂度都是 O(n )，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？

- 冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度

- 插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度

- 冒泡排序的数据交换要比插入排序的数据移动要复杂，

  - 冒泡排序需要 3个赋值操作，
  - 而插入排序只需要 1 个移动操作

  ```c++
  
  冒泡排序中数据的交换操作：
  if (a[j] > a[j+1]) { // 交换
      int tmp = a[j];
      a[j] = a[j+1];
      a[j+1] = tmp;
      flag = true;
  }
  插入排序中数据的移动操作：
  if (a[j] > value) {
      a[j+1] = a[j]; // 数据移动
  } 
  else {
      break;
  }
  ```

理论上：

- 执行一个赋值语句的时间粗略地计为单位时间（unit_time），
- 然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序
  - 用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间
  - 而插入排序中数据移动操作只需要 K 个单位时间
- 虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n^2)，
- 但是为了把性能优化做到极致，那肯定首选插入排序

####时间复杂度为 O(nlogn) 的排序算法

| 排序算法 | 事件复杂度 |      |
| :------: | :--------: | :--: |
| 归并排序 | `O(nlogn)` |      |
| 快速排序 | `O(nlogn)` |      |

归并排序和快速排序

- **适合大规模的数据**排序
- 更常用
- 都用到了**分治思想**





##### 归并排序（Merge Sort）

###### 思想：分治思想

- 将待排序数据**从中间分成前后两部分**
- 对前后两部分分别排序
- 将排好序的前后两部分合并，整个数据就有序了

分治算法一般都采用递归来实现：

- 分治——一种解决问题的处理思想
- 递归——一种编程技巧

递归代码的编码技巧

- 递推公式
- 终止条件
- 翻译代码

归并排序的递推公式：

```c++
递推公式：
merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))
    
终止条件：
p >= r 不用再继续分解
```

伪码描述：

```c++
//A 是数组，n 表示数组大小
merge_sort(A, n) {
	merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
    // 递归终止条件
    if p >= r then return
    // 取 p 到 r 之间的中间位置 q
    q = (p+r) / 2
    // 分治递归
    merge_sort_c(A, p, q)
    merge_sort_c(A, q+1, r)
    // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]
    merge(A[p...r], A[p...q], A[q+1...r])
}
```

######merge(A[p…r], A[p…q], A[q+1…r]) 的作用是

- 将已经有序的 A[p…q] 和 A[q+1…r] 合并成一个有序的数组，
- 并且放入 A[p…r]

######merge()函数如何实现呢？

```c++
merge(A[p...r], A[p...q], A[q+1...r]) {
    var i := p，j := q+1，k := 0 // 初始化变量 i, j, k
    var tmp := new array[0...r-p] // 申请一个大小跟 A[p...r] 一样的临时数组
    while i<=q AND j<=r do {
        if A[i] <= A[j] {
            tmp[k++] = A[i++] // i++ 等于 i:=i+1
        } else {
            tmp[k++] = A[j++]
        }
    }
    // 判断哪个子数组中有剩余的数据
    var start := i，end := q
    if j<=r then start := j, end:=r
    // 将剩余的数据拷贝到临时数组 tmp
    while start <= end do {
        tmp[k++] = A[start++]
    }
    // 将 tmp 中的数组拷贝回 A[p...r]
    for i:=0 to r-p do {
        A[p+i] = tmp[i]
    }
}
```

merge()函数如何借助哨兵简化编程？

to do

归并排序性能分析：

######归并排序是稳定的排序算法吗？

关键要看 merge()函数（两个有序子数组合并成一个有序数组）

- 如果 A[p…q] 和 A[q+1…r] 之间有值相同的元素，
- 可以先把 A[p…q] 中的元素放入 tmp 数组
- 这样就保证了值相同的元素，在合并前后的先后顺序不变
- 所以，归并排序可以是一个稳定的排序算法

###### 归并排序的时间复杂度是多少？

归并排序涉及递归

如何分析递归代码的时间复杂度？

- 递归的适用场景是：
  - 一个问题 a 可以分解为多个子问题 b、c，
  - 那么,求解问题a 就可以分解为求解问题 b、c
  - 问题 b、c 解决之后，再把 b、c 的结果合并成 a 的结果
- 定义:
  - 求解问题 a 的时间是 T(a)，
  - 求解问题 b、c 的时间分别是 T(b) 和 T( c)
- 递推关系式：
  - `T(a) = T(b) + T(c) + K`
  - 其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间

套用递归代码分析归并排序的时间复杂度：

- 假设对 n 个元素进行归并排序需要的时间是 T(n)，那么，分解成两个子数组排序的时间都是T(n/2)

- merge() 函数合并两个有序子数组的时间复杂度是 O(n)

- 归并排序的时间复杂度的计算公式是：

  ```c++
  T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C
  T(n) = 2*T(n/2) + n； n>1
  ```

  进一步分解计算过程:

  ```c++
  //迭代
  
  T(n)=2*T(n/2) +n
      = 2*(2*T(n/4) + n/2) + n = 4*T(n/4) + 2*n
      = 4*(2*T(n/8) + n/4) + 2*n = 8*T(n/8) + 3*n
      = 8*(2*T(n/16) + n/8) + 3*n = 16*T(n/16) + 4*n
      ......
      = 2^k * T(n/2^k) + k * n
      ......
  ```

  当 T(n/2^k)=T(1) 时，也就是n/2^k=1，我们得到 k=log n 

  将 k 值代入上面的公式，得到 T(n)=Cn+nlog n 

  用大 O标记法来表示，T(n) 就等于 O(nlogn)

  所以归并排序的时间复杂度是 O(nlogn)

归并排序的执行效率**与要排序的原始数组的有序程度无关**，

- 其时间复杂度是非常稳定的，
- 不管是最好情况、最坏情况，还是平均情况，时间复杂度都是O(nlogn)

###### 归并排序的空间复杂度是多少？

归并排序的缺陷是就地排序；

递归代码的空间复杂度并不能像时间复杂度那样累加

- 尽管每次合并操作都需要申请额外的内存空间，
- 但在合并完成之后，临时开辟的内存空间就被释放掉了
- 在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用
- 临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)





##### 快速排序（Quicksort）

###### 思想：分治思想

- 从排序数组 下标从 p 到 r 之间的一组数据中，选择 p 到 r 之间的任意一个数据作为 pivot（分区点）
- 遍历 p 到 r 之间的数据，
  - 将小于 pivot 的放到左边，
  - 将大于 pivot 的放到右边，
  - 将 pivot 放到中间
- 数组 p 到 r 之间的数据就被分成了三个部分，
  - 前面 p 到 q-1 之间都是小于pivot 的，
  - 中间是 pivot，
  - 后面的 q+1 到 r 之间是大于 pivot 的
- 根据分治、递归的处理思想，
  - 用递归排序
    - 下标从 p 到 q-1 之间的数据
    - 和下标从 q+1 到 r 之间的数据，
    - 直到区间缩小为 1，说明所有的数据都有序了

快排递推公式：

```c++
递推公式：
quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)
终止条件：
p >= r
```

伪代描述：

```c++
//A 是数组，n 表示数组的大小
quick_sort(A, n) {
	quick_sort_c(A, 0, n-1)
} 
// 快速排序递归函数，p,r为下标
quick_sort_c(A, p, r) {
    if p >= r then return
        
    q = partition(A, p, r) // 获取分区点
        
    quick_sort_c(A, p, q-1)
    quick_sort_c(A, q+1, r)
}
```

注意区别：归并排序中的merge() 合并函数

######partition() 分区函数作用是

- 随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素）
- 然后对 A[p…r] 分区，函数返回 pivot 的下标

###### partition() 分区函数如何实现

- 不考虑空间消耗的话，

  - 可以申请两个临时数组 X和 Y
  - 遍历 A[p…r]，
    - 将小于 pivot 的元素都拷贝到临时数组 X，
    - 将大于 pivot 的元素都拷贝到临时数组 Y，
    - 最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p…r]
  - 这种思路，
    - partition() 函数就需要很多额外的内存空间
    - 所以快排就不是原地排序算法了

- 在 A[p…r] 的原地完成分区操作

  ```c++
  //伪码描述
  partition(A, p, r) {
      pivot := A[r]
      i := p
      for j := p to r-1 do {
          if A[j] < pivot {
              swap A[i] with A[j]
              i := i+1
          }
  	}
  	swap A[i] with A[r]
  	return i
  }
  ```

  这里的处理有点类似选择排序：

  - 通过游标 i 把 A[p…r-1] 分成两部分
  - A[p…i-1] 的元素都是小于pivot 的——“已处理区间”，A[i…r-1] 是“未处理区间”
  - 每次都从未处理的区间 A[i…r-1] 中取一个元素 A[j]，与 pivot 对比，
  - 如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置

分区的过程涉及交换操作，快速排序并不是一个稳定的排序算法

###### 归并排序和快速排序的区别

同：

- 都是分治思想，
- 递推公式和递归代码也非常相似

区别：

归并排序

- 着重：**怎么合**
- 归并排序的处理过程是由下到上的，先处理子问题，然后再合并
- 稳定排序
- 时间复杂度为O(nlogn) 的排序算法
- 非原地排序

快速排序

- 着重：**怎么分**
- 处理过程是由上到下的，先分区，然后再处理子问题
- 不稳定排序
- 原地排序（原地分区函数，解决了归并排序占用太多内存的问题）

快速排序的性能分析：

###### 快速排序的时间复杂度是多少？

快排也是用递归来实现的

对于递归代码的时间复杂度

如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)

```c++
T(1) = C； n=1 时，只需要常量级的执行时间，所以表示为 C。
T(n) = 2*T(n/2) + n； n>1
```

公式成立的前提是每次分区操作，选择的 pivot 都很合适，

两个极端情况下的时间复杂度:

- 分区极其均衡，
  - 正好能将大区间对等地一分为二,
- 分区极其不均衡
  - 快排的时间复杂度就从 O(nlogn) 退化成了 O(n^2)

在大部分情况下的时间复杂度都可以做到 O(nlogn)



###### 快速排序的时间复杂度是多少？

就地排序，O(1)

###### 快速排序是稳定排序吗？

分区的过程涉及交换操作，快速排序并不是一个稳定的排序算法

###### O(n) 时间复杂度内求无序数组中的第 K 大元素

思路：

- 选择数组区间 A[0…n-1] 的最后一个元素 A[n-1] 作为 pivot，对数组 A[0…n-1] 原地分区，
- 分成了三部分
  - A[0…p-1]、A[p]、A[p+1…n-1]
- 如果 p+1=K，
  - A[p] 就是要求解的元素；
- 如果 K>p+1, 
  - 说明第 K 大元素出现在 A[p+1…n-1] 区间，再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找
- 如果 K<p+1，
  - 就在A[0…p-1] 区间递归查找

时间复杂度：

- 第一次分区查找，需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素
- 第二次分区查找，只需要对大小为 n/2 的数组执行分区操作，需要遍历 n/2 个元素
- 依次类推，分区遍历元素的个数分别为、n/2、n/4、n/8、n/16.……
- 直到区间缩小为 1
- 把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1
  - 这是一个等比数列求和，最后的和等于 2n-1
  - 所以，上述解决思路的时间复杂度就为 **O(n)**

另一种思路：

- 每次取数组中的最小值，将其移动到数组的最前面，
- 然后在剩下的数组中继续找最小值，
- 以此类推，执行 K 次，找到的数据不就是第 K 大元素了

另一种思路的时间复杂度：

- 是 O(K * n)
  - 当 K 是比较小的常量时，比如 1、2，最好时间复杂度是O(n)；
  - 当 K 等于 n/2 或者 n 时，这种坏情下的况时间复杂度就是 O(n ) ；





####时间复杂度为O(n)的排序算法

| 排序算法 | 时间复杂度 | 是否基于比较 |
| :------: | :--------: | :----------: |
|  桶排序  |    O(n)    |      否      |
| 计数排序 |    O(n)    |      否      |
| 基数排序 |    O(n)    |      否      |

桶排序、计数排序、基数排序三种排序的时间复杂度是线性的，因此也叫作线性排序（Linear sort）

- 主要原因是，这三个算法是**非基于比较**的排序算法，都不涉及元素之间的比较操作
- 要排序的数据要求很苛刻
- 重点掌握三种排序算法的**适用场景**





#####桶排序（Bucket sort）

######思想：

- 将要排序的数据分到几个**有序的桶**里
- 每个桶里的数据再单独进行排序
- 桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了

######复杂度分析：桶排序的时间复杂度为什么是 O(n) ？

- 如果要排序的数据有 n 个，把它们均匀地划分到 m 个桶内
- 每个桶里就有 k=n/m 个元素
- 每个桶内部使用快速排序，时间复杂度为 O(k * logk)
- m 个桶排序的时间复杂度就是 O(m * k * logk)，
- 因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))
- 当桶的个数 m 接近数据个数 n时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)

######桶排序看起来很优秀，但是桶排序对要排序数据的要求是非常苛刻的：

- 首先，要排序的数据需要很容易就能划分成 m 个桶，
- 并且，桶与桶之间有着天然的大小顺序
  - 这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序
- 其次，数据在各个桶之间的分布是比较均匀的
  - 如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了
  - 在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了

######适用场景：

桶排序比较适合用在**外部排序**中

外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中

> 比如说有 10GB 的订单数据，希望按订单金额（假设金额都是正整数）进行排序，但是内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？

借助桶排序的处理思想:

- 先扫描一遍文件，看订单金额所处的数据范围
- 假设扫描之后得到，订单金额最小是 1 元，最大是 10 万元
- 将所有订单根据金额划分到 100 个桶里，
  - 第一个桶我们存储金额在 1 元到 1000 元之内的订单，
  - 第二桶存储金额在 1001 元到 2000 元之内的订单，
  - 以此类推
- 每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）
- 理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，
  每个小文件中存储大约 100MB 的订单数据，
- 就可以将这 100 个小文件依次放到内存中，用快排来排序
- 等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了

不过，订单按照金额在 1 元到 10 万元之间并不一定是均匀分布的 ，所以 10GB订单数据是无法均匀地被划分到 100 个文件中的有可能某个金额区间的数据特别多，划分之后对应的文件就会很大，没法一次性读入内存。这又该怎么办呢？

针对这些划分之后还是比较大的文件，可以**继续划分**

- 比如，订单金额在 1 元到 1000 元之间的比较多，就将这个区间继续划分为 10 个小区间，
- 1 元到 100 元，101 元到 200 元，201 元到 300 元…901 元到 1000 元
- 如果划分之后，101 元到 200 元之间的订单还是太多，无法一次性读入内存，那就**继续再划分**，
- **直到所有的文件都能读入内存为止**





##### 计数排序（Counting sort）

######思想：

当要排序的 n 个数据，所处的范围最大值是 k，可以把数据划分成 k 个桶

- 数据的范围不大（k不大）
- 每个桶内的数据值都是相同的（省掉了桶内排序的时间）
- 可以视为**桶排序的特殊情况**(**桶的大小**不一样)

> 如果有 50 万考生，如何通过成绩快速排序得出名次呢？

- 考试成绩满分为k，成绩范围为0~k（k的范围不大）
- 扫描遍历50万考生成绩，划分到k+1个桶里
- 桶内的数据都是分数相同的考生，并不需要再进行排序
- 依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序

######时间复杂度

只涉及扫描遍历操作，所以时间复杂度是 O(n)

###### “计数”的含义

举个栗子：

a[n]:包含原始数据的数组a，数据的范围是0~k(k<<n);

b[k]:遍历原始数据，将n个数据划分到k+1个桶中（默认b[]中数据是按照下标递增的）

c[]:计数排序后的数组

思路：

- 顺序求和b[]数组，b[i] (i<k-1):代表原始数据中小于等于i的数据的个数
- 将i追加到c[]中，b[i]--（小于等于i的数据个数减一）
- 重复上述步骤

###### 适用场景

计数排序只能用在数据范围不大的场景中

- 如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序

而且，计数排序只能给非负整数排序

- 如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数





##### 基数排序（Radix sort）

###### 问题：给10 万个手机号码从小到大排序

- 快排，时间复杂度是 O(nlogn)（可以更下吗？）
- 桶排序、计数排序，手机号码11位，范围太大

数据的特点：

如果a手机号码的前面某位数字已经比b手机号码大了，就不用继续比较了

思路：借助稳定排序算法

- 先按照最后一位来排序手机号码，

- 然后，再按照倒数第二位重新排序，

- 以此类推...

- 最后按照第一位重新排序

- 经过 11 次排序之后，手机号码就都有序了

  按照每位来排序的排序算法要是稳定的，否则这个实现思路就是不正确的

  根据每一位来排序，我们可以用桶排序或者计数排序,时间复杂度可以做到 O(n)

  如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)

  手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于
  O(n)

###### 排序的数据并不都是等长的怎么办

> 排序牛津字典中的 20 万个英文单词(最短有 1 个字母，最长的有 45 个字母)

策略：补齐到相同长度，就可以达到继续使用基数排序的母的

适应的场景：

基数排序对要排序的数据的要求

- 可以分割出独立的“位”来比较
- 位之间有递进的关系
  - 如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了
- 每一位的数据范围不能太大
  - 要可以用线性排序算法来排序
  - 否则，基数排序的时间复杂度就无法达到O(n) 





#### 排序优化：如何实现一个通用的、高性能的排序函数？

几乎所有的编程语言都会提供排序函数，比如 C 语言中 qsort()，C++ STL 中的 sort()、stable_sort()

##### 如何选择合适的排序算法？

|          |      时间复杂度       | 是稳定排序？ | 是原地排序？ |
| :------: | :-------------------: | :----------: | :----------: |
| 冒泡排序 |        O(n^2)         |      是      |      是      |
| 插入排序 |        O(n^2)         |      是      |      是      |
| 选择排序 |        O(n^2)         |      否      |      是      |
| 归并排序 |       O(nlogn)        |      是      |      否      |
| 快速排序 |       O(nlogn)        |      否      |      是      |
|  桶排序  |         O(n)          |      是      |      否      |
| 计数排序 | O(n+k)（k是数据范围） |      是      |      否      |
| 基数排序 |   O(dn)（d是维度）    |      是      |      否      |

**线性排序算法的时间复杂度比较低，适用场景比较特殊**

- 所以如果要写一个通用的排序函数，不能选择线性排序算法

对**小规模数据**进行排序，可以选择**时间复杂度是 O(n )** 的算法；

对**大规模数据**进行排序，**时间复杂度是 O(nlogn)** 的算法更加高效

- 所以，**为了兼顾任意规模数据**的排序，一般都会**首选时间复杂度是 O(nlogn) 的排序算法**来实现排序函数
- 时间复杂度是 O(nlogn) 的排序算法不止一个，
  - 归并排序、
  - 快速排序，
  - 堆排序
- **堆排序和快速排序都有比较多的应用**

**使用归并排序的情况其实并不多**，为什么？

- 快排在最坏情况下的时间复杂度是 O(n^2)，而归并排序可以做到平均情况、最坏情况下的时间复杂度都是 O(nlogn)，
- 归并排序并不是原地排序算法，空间复杂度是O(n)
  - **空间耗费翻倍**(这是归并排序最大的痛点)





##### 如何优化快速排序？

###### 为什么最坏情况下快速排序的时间复杂度是 O(n ) 呢？（主要原因是分区点选的不够合理）

- 如果数据原来就是**有序的或者接近有序**的，
- 每次分区点都选择**最后一个数据**，(分区点不合理)
- 那快速排序算法时间复杂度就会退化为 **O(n ^2)**



###### 合理选择分区点

如何选择分区点呢？

**最理想的分区点**是：被分区点分开的两个分区中，数据的数量差不多（**均分**）

实际达不到理想的状态，但也要**尽可能地让每次分区都比较平均**

比较常用、比较简单的分区算法：

1. 三数取中法
   - 从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分
   - 如果要排序的数组比较大，那“三数取中”可能就不够，可以“五数取中”或者“十数取中”
2. 随机法
   - 每次从要排序的区间中，随机选择一个元素作为分区点
   - 时间复杂度退化为最糟糕的 O(n ) 的情况，出现的可能性不大
3. to do



###### 警惕堆栈溢出

快速排序是用递归来实现的

为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，两种解决办法：

- 第一种是限制递归深度
  - 一旦递归过深，超过了我们事先设定的阈值，就停止递归
- 第二种是通过在堆上模拟实现一个函数调用栈
  - 手动模拟递归压栈、出栈的过程，
  - 就没有了系统栈大小的限制



##### 举例分析排序函数：qsort() 函数

qsort() 函数不仅仅用了快排这一种算法：

- 对于**小数据量**的排序，qsort() 会优先使用**归并排序**来排序输入数据（**用空间换时间**）
- 对于**大数据量**的排序，qsort() 会改为用**快速排序**算法来排序
  - 如何选取分区点
    - qsort() 选择分区点的方法就是“**三数取中法”**
  - 如何解决栈溢出
    - qsort() 自己**实现一个堆上的栈，手动模拟递归**

- **插入排序**
  - 在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，
  - qsort() 就退化为插入排序，不再继续用递归来做快速排序，
  - **在小规模数据面前，O(n^2) 时间复杂度的算法并不一定比O(nlogn) 的算法执行时间长**



###### O(n^2) 时间复杂度一定比O(nlogn) 的算法执行时间长吗？

算法的性能可以通过时间复杂度来分析，但是，**时间复杂度并不等于代码实际的运行时间**

时间复杂度代表的是一个增长趋势，在大 O 复杂度表示法中，会**省略低阶、系数和常数**

O(nlogn) 在没有省略低阶、系数、常数之前

- 可能是 O(knlogn + c)，
- 而且 k 和c 有可能还是一个比较大的数

```c++
knlogn+c = 1000 * 100 * log100 + 200 远大于 10000
n^2 = 100*100 = 10000
```

所以，对于小规模数据的排序，O(n ) 的排序算法并不一定比 O(nlogn) 排序算法执行的时间长

- 对于**小数据量**的排序，**选择比较简单、不需要递归的插入排序算法**