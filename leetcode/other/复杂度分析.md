### 复杂度分析



一，如何衡量代码的**执行效率和资源消耗**？

- 时间复杂度分析
- 和空间复杂度分析

二，为什么需要复杂度分析？

- 跑一遍——时候统计法——可行
- 但是有很大的局限性
  - 测试结果依赖**测试环境（CPU，内存）**
  - 测试结果依赖**数据规模（大小，有序，乱序，无序，部分有序）**

三，大O复杂度表示法

​	

- **假设每行代码执行的时间相等**（粗略估计）为——unit-time，
- 代码执行的总时间T（n）是多少？
  - **T（n）和每行代码执行的次数n成正比**
  - **T(n)=O(f(n))**
    - **T(n)——代码执行的总时间**
    - **n——数据规模**
    - **f(n)——每行代码执行次数的总和**
    - **O——成正比**
- 大O表示法——其实是表示**代码执行时间随数据规模增长的变化趋势**
  - 所以，也叫渐进时间复杂度(asymptotic time complexity)——简称时间复杂度

四，时间复杂度分析

- **循环——执行次数最多的代码**

  ```cpp
  int sum=0;//O(1)
  
  for(;i<n;i++){
      sum+=i;//O(n)
  }
  
  //O(n)
  ```

- 加法法则：总时间复杂度等于量级最大的那段代码的复杂度——**求最大**

  ```cpp
  int sum=0;//O(1)
  
  for(int i=0;i<1000;i++){
      sum+=i;//1000--O(1)
  }
  
  for(int i=0;i<n;i++){
      sum+=i;//O(n)
  }
  
  //O(n)
  ```

- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积——**求乘积（递归，循环）**

  ```cpp
  int sum=0;//O(1)
  
  for(int i=0;i<1000;i++){
      int j=0;//1000--O(1)
      for(;j<n;j++){
          sum+=j;//O(1000*n)--O(n)
      }
  }
  
  //O(n)
  ```

五，复杂度量级（递增）

- **常量阶——O(1)**
- **对数阶——O(logn)**
- **线性阶——O(n)**
- **线性对数阶——O(nlogn)**
- **平方阶——O(n^2)，立方 阶——O(n^3)，k次方阶——O(n^k)**
- **非多项式量级NP（Non-Deterministic Polynomial）**

  - 指数阶——O(2^n)
  - 阶乘阶——O(n!)
- 常见的几种复杂度分析
  1. **O(1)**

     - 并不是指代码指执行了一次
     - 代码的执行时间**不随数据规模n的增长而增长**——都是常量阶O(1)

  2. **O(logn),O(nlogn)**

     ```cpp
     int i=0;//O(1)
     
     while(i<=n){
         i+=2;
     }
     
     //2^k==n
     //k=log2n
     
     //O(logn)
     ```

     - **对数阶O(logn)可以忽略底数**
     - 的原因是——对数的性质（换底公式），提出常量可以忽略
     - O(nlogn)是O(logn)乘法法则的应用

  3. O(m+n),O(m*n)

     ```cpp
     for(;i<m;i++){
         sum+=i;
     }
     
     for(;j<n;j++){
         sum+=j
     }
     ```

     - **m和n的数据量级未知**，不能随便省略某一个，因此时间复杂度是O(m+n);
     - 乘法规则类似——O(m*n)

六，空间复杂度分析

```cpp
int i=0;//O(1)--申请了一块空间存储变量i

int arr[n]={0};//O(n)--申请大小为n的int型数组空间

for(;i<n;i++){
    sum+=i;
}

//后续没有开辟空间

//O(n)
```

- 类似的，空间复杂度是渐进空间复杂度（asymptotic space complexity）的简称
- 表示算法的存储空间随数据规模的增长关系



### 最好，最坏，平均，均摊复杂度分析



simple1:

```cpp
//在array中查找x出现的位置

// n 表示数组 array 的长度

int find(int[] array, int n, int x) {
    int i = 0;
    int pos = -1;
    for (; i < n; ++i) {
        if (array[i] == x) {
            pos = i;
            break;
        }
    }
    return pos;
}
```

这段代码的复杂度是多少？

- 要查找的**x可能出现在数组的任意位置**
  - 如果第一个位置就是要找的x，那么时间复杂度就是——**O(1)——最好时间复杂度**
  - 如果最后一个位置是要找的x，或者x不在数组中，那么时间复杂度就是——**O(n)——最坏时间复杂度**
- 所以，**不同情况下这段代码的时间复杂度不同**

  - 然而，最好和最坏的情况发生的概率并不大
  - 因此，可以用平均情况时间复杂度来衡量——**平均时间复杂度**
    - x的位置，有n+1种情况
      - 在数组0~n-1中
      - 不在数组中
    - 累加遍历的次数/(n+1)==遍历的平均值
      - n(n+3)/2(n+1)
    - 忽略系数，低阶，常量——得到的平均时间复杂度就是——O(n)
    - **但是，这n+1中情况发生的概率并不一样**
      - 要么在数组里
      - 要么没有在数组里
      - 概率不好统计
      - 假设，在数组中和不在数组中的概率都是1/2
        - 0~n这n个位置（数组中）出现的概率是1/2n
        - 不在数组中的概率是1/2
      - 因此，累加遍历的次数*概率==遍历的平均值
        - （3n+1）/4
        - 加权平均值（期望）——**加权（期望）平均时间复杂度**
        - 去掉系数和常量——加权平均时间复杂度仍然是——O(n)

simple2:

```cpp
//往数组中插入数据,当数组满了之后，我们用 for 循环遍历数组求和，并清空数组，将求和之后的
//sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接
//将数据插入数组

// array 表示一个长度为 n 的数组
// array.length 就等于 n

int[] array = new int[n];
int count = 0;
    void insert(int val) {
    if (count == array.length) {
        int sum = 0;
        for (int i = 0; i < array.length; ++i) {
            sum = sum + array[i];
        }
        array[0] = sum;
        count = 1;
    }
    array[count] = val;
    ++count;
}
```

这段代码的复杂度是多少呢？

- 最理想的情况下，数组中有空闲空间，直接插入，那么最好的时间复杂度是——O(1)
- 最坏的情况下，数组中没有空间了，先做数组遍历求和，再插入，因此最坏情况时间复杂度是——O(n)
- 平均时间复杂度呢？
  - 插入位置的不同，有n+1种情况
    - 0~n-1种位置（在数组中）——时间复杂度为——O(1)
    - 数组没有空闲空间插入——时间复杂度为——O(n)
    - 假设n+1种情况发生的概率都是1/（n+1）
      - 加权平均求得，平均时间复杂度为——O(1)
  - insert()和find()的区别
    - find()在极端情况下才为O(1)
    - insert()在大部分情况下都为O(n)
      - O(1)和O(n),有一定的时序关系——一个O(n)后紧挨着n-1个O(1),循环往复
  - 针对这样的特殊情况看，可以采用——均摊时间复杂度
    - 每一次O(n)操作都会跟着n-1次O(1)操作
    - 所以把耗时多的操作均摊到n-1次操作上
    - 那么这一组连续的操作的均摊时间复杂度就是O(1)
  - **均摊时间复杂度的应用场景**
    - 大部分时间复杂度都很低，**个别情况时间复杂度比较高**
    - 并且，**操作之间存在时序关系**
    - 可以将连续操作的较高复杂度均摊到较低操作上
    - **一般均摊时间复杂度就等于最好的时间复杂度**




