### 一，如何理解递归

坐在第几排？（递归的思路）

- 问前一排的人他是第几排，在他的数字上加一，就知道自己在哪一排了
- 前一排问他前面的人
- 一排一排往前问
- 直到问道第一排（将排数一排一排传回去）

去的过程叫——“`递`”，回来的过程叫——“`归`”（回溯）

用递推公式表示

```c++
f(n)=f(n-1)+1;

f(1)=1;

//f(n)自己的位置
//f(n-1)前一排所在排数
//f(1)第一排
```

代码实现：

```c++
int f(int n){
    if(n==1){
        return 1;
    }
    return f(n-1)+1;
}
```

### 二，递归满足的条件

- 一个问题的解可以分解成多个**子问题**（规模更小的问题）的解
- 分解之后的子问题和原问题，出了数据规模不同，**求解思路一样**
- 存在**递归终止的条件**
- 不能存在无限循环

### 三，如何写递归代码

**关键：求出递推公式，找到终止条件，翻译代码**

> 问题：假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？
思路：

- 根据第一步的走法把所有走法分为两类，
  - 第一类是第一步走了 1 个台阶，（最后一步走了1个台阶）
  - 另一类是第一步走了 2 个台阶，（最后一步走了2个台阶）
  - 所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法
- 递推公式：`f(n) = f(n-1)+f(n-2)`
- 终止条件：
  - 当有一个台阶时，不需要再继续递归，就只有一种走法，所以 f(1)=1
  - f(2)=2

翻译代码：

```c++
int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    return f(n-1) + f(n-2);
}
```

### 四，思维方式:

如果一个问题 A 可以分解为若干子问题 B、C、D，

- 可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A
- 只需要思考问题 A 与子问题 B、C、D 两层之间的关系
- 不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系
- 屏蔽掉递归细节，防止陷入思维误区

### 五，警惕堆栈溢出

堆栈溢出会造成系统性崩溃，后果会非常严重

> 函数调用会使用栈来保存临时变量
>
> 每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈
>
> 系统栈或者虚拟机栈空间一般都不大,
>
> 如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。
>
> 如何避免出现堆栈溢出呢？

思路一：递归调用超过一定深度（比如 1000）之后，不再继续递归，直接返回报错

思路二：根据当前栈空间大小决定（实时计算，复杂）

### 六，警惕重复计算

解决思路：

- 利用散列表或map保存已经求解过得`f(k)`

### 七，如何将递归代码改写为非递归代码？

递归有利有弊，

利是

- 递归代码的表达力很强，写起来非常简洁；

而弊是

- 空间复杂度高、
- 有堆栈溢出的风险、
- 存在重复计算、过多的函数调用会耗时较多

考虑是否采用递归？——转化为非递归

```c++
int f(int n){
    if(n==1){
        return 1;
    }
    return f(n-1)+1;
}
//递推公式：f(x)=f(x-1)+1
//转化为非递归
int f(int n) {
    int ret = 1;
    for (int i = 2; i <= n; ++i) {
    	ret = ret + 1;
    }
    return ret;
}



int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    return f(n-1) + f(n-2);
}
//递推公式：f(n) = f(n-1)+f(n-2)
//转化为非递归
int f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    int ret = 0;
    int pre = 2;
    int prepre = 1;
    for (int i = 3; i <= n; ++i) {
        ret = pre + prepre;
        prepre = pre;
        pre = ret;
    }
    return ret;
}
```

//斐波拉契数列--非递归实现

其实，就是一个回溯循的过程（循环求和）

### 八，递归中环的问题

如果存在脏数据，就可能出现无限循环的可能（环）

如何检测环的存在？

思路一：每次访问先比较map中是否存在该数据

思路二：用一个数据域或变量记录访问的状态