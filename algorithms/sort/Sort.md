### 如何评价和分析一个排序算法？

- 排序算法的**执行效率**

  1. 最好，最坏，平均时间复杂度

     - 不同时间复杂度下，对应的原始数据（规模大小，有序，近乎有序，无序，乱序）

  2. 时间复杂度的系数，常数，低阶

     - 同阶复杂度的算法对比算法性能时考虑系数，常数，低阶

  3. 比价次数和交换（或移动）次数

     - 基于排序算法

- 排序算法的**内存消耗**（空间复杂度）

  - 引入：就地排序（原地排序）（sorted in place）

  - 不利用额外的空间（常量级的空间）

- 空间复杂度是 O(1)的排序算法

- 排序算法的**稳定性**

  - 排序之后，相等元素之间原有的先后顺序不变

  - 实例：按照对象的某个属性值排序（应用广泛）

##### 排序的数据并不都是等长的怎么办

> 排序牛津字典中的 20 万个英文单词(最短有 1 个字母，最长的有 45 个字母)
> 策略：补齐到相同长度，就可以达到继续使用基数排序的母的
> 适应的场景：
> 基数排序对要排序的数据的要求

- 可以分割出独立的“位”来比较
- 位之间有递进的关系
  - 如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了
- 每一位的数据范围不能太大
  - 要可以用线性排序算法来排序
  - 否则，基数排序的时间复杂度就无法达到 O(n)

### 排序优化：如何实现一个通用的、高性能的排序函数？

几乎所有的编程语言都会提供排序函数，比如 C 语言中 `qsort()`，C++ STL 中的 sort()、stable_sort()

#### 如何选择合适的排序算法？

|          |       时间复杂度       | 是稳定排序？ | 是原地排序？ |
| :------: | :--------------------: | :----------: | :----------: |
| 冒泡排序 |         O(n^2)         |      是      |      是      |
| 插入排序 |         O(n^2)         |      是      |      是      |
| 选择排序 |         O(n^2)         |      否      |      是      |
| 归并排序 |       `O(nlogn)`       |      是      |      否      |
| 快速排序 |       `O(nlogn)`       |      否      |      是      |
|  桶排序  |          O(n)          |      是      |      否      |
| 计数排序 | O(n+k)（k 是数据范围） |      是      |      否      |
| 基数排序 |  `O(dn)`（d 是维度）   |      是      |      否      |

**线性排序算法的时间复杂度比较低，适用场景比较特殊**

- 所以如果要写一个通用的排序函数，不能选择线性排序算法
  对**小规模数据**进行排序，可以选择**时间复杂度是 O(n )** 的算法；
  对**大规模数据**进行排序，**时间复杂度是 `O(nlogn)`** 的算法更加高效
- 所以，**为了兼顾任意规模数据**的排序，一般都会**首选时间复杂度是 `O(nlogn)` 的排序算法**来实现排序函数
- 时间复杂度是 `O(nlogn)`的排序算法不止一个，
  - 归并排序
  - 快速排序
  - 堆排序
- **堆排序和快速排序都有比较多的应用**
  **使用归并排序的情况其实并不多**，为什么？
- 快排在最坏情况下的时间复杂度是 O(n^2)，而归并排序可以做到平均情况、最坏情况下的时间复杂度都是 O(nlogn)，
- 归并排序并不是原地排序算法，空间复杂度是 O(n)
  - **空间耗费翻倍**(这是归并排序最大的痛点)

#### 如何优化快速排序？

##### 为什么最坏情况下快速排序的时间复杂度是 O(n ) 呢？（主要原因是分区点选的不够合理）

- 如果数据原来就是**有序的或者接近有序**的，
- 每次分区点都选择**最后一个数据**，(分区点不合理)
- 那快速排序算法时间复杂度就会退化为 **O(n ^2)**

##### 合理选择分区点

如何选择分区点呢？
**最理想的分区点**是：被分区点分开的两个分区中，数据的数量差不多（**均分**）
实际达不到理想的状态，但也要**尽可能地让每次分区都比较平均**
比较常用、比较简单的分区算法：

1. 三数取中法
   - 从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分
   - 如果要排序的数组比较大，那“三数取中”可能就不够，可以“五数取中”或者“十数取中”
2. 随机法
   - 每次从要排序的区间中，随机选择一个元素作为分区点
   - 时间复杂度退化为最糟糕的 O(n ) 的情况，出现的可能性不大
3. to do

##### 警惕堆栈溢出

快速排序是用递归来实现的
为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，两种解决办法：

- 第一种是限制递归深度
  - 一旦递归过深，超过了我们事先设定的阈值，就停止递归
- 第二种是通过在堆上模拟实现一个函数调用栈
  - 手动模拟递归压栈、出栈的过程，
  - 就没有了系统栈大小的限制

#### 举例分析排序函数：`qsort()`函数

`qsort()`函数不仅仅用了快排这一种算法：

- 对于**小数据量**的排序，`qsort()`会优先使用**归并排序**来排序输入数据（**用空间换时间**）
- 对于**大数据量**的排序，`qsort()`会改为用**快速排序**算法来排序
  - 如何选取分区点
    - `qsort()`选择分区点的方法就是“**三数取中法”**
  - 如何解决栈溢出
    - `qsort()`自己**实现一个堆上的栈，手动模拟递归**
- **插入排序**
  - 在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，
  - `qsort()` 就退化为插入排序，不再继续用递归来做快速排序，
  - **在小规模数据面前，O(n^2) 时间复杂度的算法并不一定比`O(nlogn)`的算法执行时间长**

##### O(n^2) 时间复杂度一定比`O(nlogn)` 的算法执行时间长吗？

算法的性能可以通过时间复杂度来分析，但是，**时间复杂度并不等于代码实际的运行时间**
时间复杂度代表的是一个增长趋势，在大 O 复杂度表示法中，会**省略低阶、系数和常数**
`O(nlogn)` 在没有省略低阶、系数、常数之前

- 可能是 `O(knlogn + c)`，
- 而且 k 和 c 有可能还是一个比较大的数

```c++
knlogn+c = 1000 * 100 * log100 + 200 远大于 10000
n^2 = 100*100 = 10000
```

所以，对于小规模数据的排序，O(n ) 的排序算法并不一定比 `O(nlogn)`排序算法执行的时间长

- 对于**小数据量**的排序，**选择比较简单、不需要递归的插入排序算法**
